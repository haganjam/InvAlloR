<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Description of the model forms for the equations • InvAlloR</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Description of the model forms for the equations">
<meta name="description" content="Notes on the model forms used in package.
">
<meta property="og:description" content="Notes on the model forms used in package.
">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">InvAlloR</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.0.0.1</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/InvAlloR-detailed-output-description.html">Detailed description of the output</a></li>
    <li><a class="dropdown-item" href="../articles/InvAlloR-technical-information.html">Description of the model forms for the equations</a></li>
    <li><a class="dropdown-item" href="../articles/InvAlloR-user-guide.html">Using InvAlloR</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/haganjam/InvAlloR/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Description of the model forms for the equations</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/haganjam/InvAlloR/blob/HEAD/vignettes/InvAlloR-technical-information.Rmd" class="external-link"><code>vignettes/InvAlloR-technical-information.Rmd</code></a></small>
      <div class="d-none name"><code>InvAlloR-technical-information.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="forms-of-the-length-dry-biomass-allometric-equations-in-invallor">Forms of the length-dry biomass allometric equations in
<code>InvAlloR</code><a class="anchor" aria-label="anchor" href="#forms-of-the-length-dry-biomass-allometric-equations-in-invallor"></a>
</h2>
<p>Based on an extensive review of the literature of length-dry biomass
allometric equations for freshwater invertebrates, there are two
different model forms.</p>
<div class="section level3">
<h3 id="model-form-1">Model form 1<a class="anchor" aria-label="anchor" href="#model-form-1"></a>
</h3>
<p>The the most common model form in the literature is a power function
with a multiplicative error structure (<em>model1</em> in the
<code>InvAlloR</code> package):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>X</mi><mi>b</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><msup><mi>e</mi><mi>ϵ</mi></msup></mrow><annotation encoding="application/x-tex">
Y = a(X^b) \cdot e^\epsilon \tag{Equation-1}
</annotation></semantics></math></p>
<p>This is the model that is fit when both the Y (i.e. dry biomass) and
X (i.e. body size) variables are log-transformed. For example, let’s
consider taking the natural logarithm of both sides of this
equation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>l</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>l</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>X</mi><mi>b</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">
ln(Y) = ln(a) + ln(X^b) + \epsilon \tag{Equation-2}
</annotation></semantics></math></p>
<p>This equation simplifies to:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>l</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>⋅</mo><mi>l</mi><mi>n</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">
ln(Y) = ln(a) + (b \cdot ln(X)) + \epsilon \tag{Equation-3}
</annotation></semantics></math></p>
<p>This simplified version is the standard linear regression equation.
However, given that we fit the model in log-log space with additive
error, when we back-transform the error, it is no longer centered on
zero. This means that we typically require a correction factor to obtain
the appropriate back-transformed Y value (compare Equation 1 with
Equation 3).</p>
</div>
<div class="section level3">
<h3 id="model-form-2">Model form 2<a class="anchor" aria-label="anchor" href="#model-form-2"></a>
</h3>
<p>The second model form (<em>model2</em> in the <code>InvAlloR</code>
package) is a model that is fit directly using non-linear regression
model:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>a</mi><mo>⋅</mo><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>X</mi><mi>b</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">
Y = a \cdot (X^b) + \epsilon \tag{Equation-4}
</annotation></semantics></math></p>
<p>When models are fit using this type of non-linear regression
equation, then we do not need any corrections to get the predictions of
Y back onto the natural scale.</p>
<p>The vast majority of allometric equations in the literature and in
the <code>InvAlloR</code> database take the form of model1.</p>
</div>
</div>
<div class="section level2">
<h2 id="correction-factors-for-back-transforming-log-log-models">Correction factors for back-transforming log-log models<a class="anchor" aria-label="anchor" href="#correction-factors-for-back-transforming-log-log-models"></a>
</h2>
<p>The <code>InvAlloR</code> package automatically implements a range of
correction factors to the dry biomass outputs. We detail the various
correction factors that are implemented in <code>InvAlloR</code>. The
specific correction factor used, however, depends on information
available for the equation (see details below).</p>
<p>The problems with using log-log models (i.e. <em>model1</em> forms)
for prediction on the original scale of the response variable are well
known (e.g. Marhrlein et al. 2016). Models of the form:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>a</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>X</mi><mi>b</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><msup><mi>e</mi><mi>ϵ</mi></msup></mrow><annotation encoding="application/x-tex">
Y = a(X^b) \cdot e^\epsilon \tag{Equation-5}
</annotation></semantics></math> Are typically transformed onto the
log-scale as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">
log(Y) = log(a) + (b \cdot log(X)) + \epsilon \tag{Equation-6}
</annotation></semantics></math></p>
<p>The problem with this transformation is that the errors become
multiplicative and not additive on the log-scale. Thus, predictions of
the expected value of Y become the geometric mean rather than the
arithmetric which is always an underestimation. This means that
predictions on the original-scale tend to be biased in such models. How
does this bias work mathematically?</p>
<p>When we fit the model on the log-scale, we get the expected value of
log(y) given X which is just the fitted model coefficients multiplied by
the predictor variables with some additive error.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="prefix">|</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>β</mi><mrow><mi>f</mi><mi>i</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">
E(log(Y)|log(X)) = \beta_{fitted} \cdot log(X) + \epsilon \tag{Equation-7}
</annotation></semantics></math></p>
<p>We, however, want the following:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><mo stretchy="false" form="prefix">|</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
E(e^{log(Y)} |log(X)) \tag{Equation-8}
</annotation></semantics></math></p>
<p>But, if we simply take the exponential of both sides of the equation,
we get the following:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>e</mi><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="false" form="prefix">|</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><mo>=</mo><msup><mi>e</mi><mrow><msub><mi>β</mi><mrow><mi>f</mi><mi>i</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>ϵ</mi></mrow></msup></mrow><annotation encoding="application/x-tex">
e^{E(log(Y)|log(X))} = e^{\beta_{fitted} \cdot log(X) + \epsilon} \tag{Equation-9}
</annotation></semantics></math></p>
<p>We solve this by taking the expectation of both sides E and after
some simplification, we get to:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>Y</mi><mo stretchy="false" form="prefix">|</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>e</mi><mrow><msub><mi>β</mi><mrow><mi>f</mi><mi>i</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow></msub><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>X</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>e</mi><mi>ϵ</mi></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
E(Y|X) = E(e^{\beta_{fitted} \cdot log(X)}) \cdot E(e^{\epsilon}) \tag{Equation-10}
</annotation></semantics></math> This shows that to get the quantity we
want (i.e. E(Y|X)), we need to multiply the model prediction by the
expectation of the exponentiated errors.</p>
<p>There are several correction factors that can be used to solve this
issue. <code>InvAlloR</code> uses three of these correction factors
which depend on different sources of information (e.g. model fit:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>r</mi><mn>2</mn></msup><annotation encoding="application/x-tex">r^2</annotation></semantics></math>,
maximimum and minimum y-values, residual mean square and the
residuals).</p>
<div class="section level3">
<h3 id="duans-smearing-factor">Duan’s smearing factor<a class="anchor" aria-label="anchor" href="#duans-smearing-factor"></a>
</h3>
<p>The first correction that we use is the standard Duan’s smearing
factor (Duan 1983, <em>Journal of the American Statistical
Association</em>). This correction factor requires data on the residuals
to calculate and, therefore, it is typically not easy to extract from
the literature. However, some papers report it and we directly digitised
scatter plots and calculated it for some other equations.</p>
<p>The smearing factor is calculated as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><msup><mi>e</mi><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>i</mi><mi>d</mi><mi>u</mi><mi>a</mi><mi>l</mi><mi>s</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
E(e^{residuals}) \tag{Equation-11}
</annotation></semantics></math></p>
<p>Or, if using a different logarithm base:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>b</mi><mi>a</mi><mi>s</mi><msup><mi>e</mi><mrow><mi>r</mi><mi>e</mi><mi>s</mi><mi>i</mi><mi>d</mi><mi>u</mi><mi>a</mi><mi>l</mi><mi>s</mi></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
E(base^{residuals}) \tag{Equation-12}
</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="bird-and-prairie-1985">Bird and Prairie (1985)<a class="anchor" aria-label="anchor" href="#bird-and-prairie-1985"></a>
</h3>
<p>The correction factor proposed by Bird and Prairie (1985, <em>Journal
of Plankton Research</em>) is to multiply the antilog of the outputted
dry biomass on the natural scale by the following correction factor
which uses the residual mean square (RMS):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>e</mi><mfrac><mrow><mi>R</mi><mi>M</mi><mi>S</mi></mrow><mn>2</mn></mfrac></msup><annotation encoding="application/x-tex">
e^{\frac{RMS}{2}} \tag{Equation-13}
</annotation></semantics></math></p>
<p>Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">RMS</annotation></semantics></math>
is the residual mean square which is the same as the mean squared error
(see <em>MSE, RMS and RMSE</em> section below).</p>
</div>
<div class="section level3">
<h3 id="strimbu-et-al--2018">Strimbu <em>et al.</em> (2018)<a class="anchor" aria-label="anchor" href="#strimbu-et-al--2018"></a>
</h3>
<p>The vast majority of correction factors to deal with the
log-transformation bias rely on knowing the standard deviation of the
model residuals. However, when researchers compile equations from the
literature, usually they do not have access to the standard deviation of
the residuals. This means that the typical correction factors do not
work in these cases.</p>
<p>Strimbu et al. (2018, <em>Forestry</em>) recently proposed a set of
correction factors that work when access to the residuals of the model
are not available. For <code>InvAlloR</code>, we generally only have
information on the equation, the range of X values that were used to fit
the equation and the coefficient of determination (i.e. the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>r</mi><mn>2</mn></msup><annotation encoding="application/x-tex">r^2</annotation></semantics></math>
value). Using Strimbu et al.’s (2018, <em>Forestry</em>) correction
factors, this information tends to be sufficient.</p>
<p>Specifically, Strimbu et al. (2018, <em>Forestry</em>) propose two
correction factors that we may be able to use on log-linear equations in
our database:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>C</mi><mn>3</mn><mo>=</mo><msup><mi>e</mi><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.5</mn><mo>⋅</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><msup><mi>r</mi><mn>2</mn></msup><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mo>⋅</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac><mn>1</mn><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac><mo>⋅</mo><mfrac><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>b</mi><mo>=</mo><mi>a</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>b</mi><mo>=</mo><mi>a</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>6</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow></msup></mrow><annotation encoding="application/x-tex">
BC3 = e^{(0.5 \cdot (1-r^2)) \cdot  (\frac{1}{log(a)} \cdot \frac{( log_{b=a}(y_{max})-log_{b=a}(y_{max}) )}{6})^2} \tag{Equation-14}
</annotation></semantics></math></p>
<p>The other correction factor that does not require
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>r</mi><mn>2</mn></msup><annotation encoding="application/x-tex">r^2</annotation></semantics></math>
is:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>C</mi><mn>4</mn><mo>=</mo><msup><mi>e</mi><mrow><mfrac><mn>1</mn><mrow><mi>l</mi><mi>o</mi><mi>g</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>a</mi><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow></mfrac><mo>⋅</mo><mfrac><msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>b</mi><mo>=</mo><mi>a</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>b</mi><mo>=</mo><mi>a</mi></mrow></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mn>72</mn></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">
BC4 = e^{\frac{1}{log(a)^2} \cdot \frac{( log_{b=a}(y_{max})-log_{b=a}(y_{min}) )^2}{72}} \tag{Equation-15}
</annotation></semantics></math></p>
</div>
<div class="section level3">
<h3 id="mse-rms-and-rmse">MSE, RMS and RMSE<a class="anchor" aria-label="anchor" href="#mse-rms-and-rmse"></a>
</h3>
<p>In much of the older literature, there tends to be some confusion
about the use of different terms like mean square error, residual mean
square and root mean squared error.</p>
<p>To make sure that this is clear, as far as we can tell, the mean
squared error
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>S</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">MSE</annotation></semantics></math>)
is calculated in the same way as residual mean square
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">RMS</annotation></semantics></math>).
It appears that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">RMS</annotation></semantics></math>
is the older term. Nonetheless, it is calculated as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>S</mi><mi>E</mi><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>⋅</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">
MSE = \frac{1}{n} \cdot \sum_{i=1}^{n} (y_{i} - \hat{y}_{i}) \tag{Equation-16}
</annotation></semantics></math></p>
<p>Where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>y</mi><mi>i</mi></msub><annotation encoding="application/x-tex">y_i</annotation></semantics></math>
is the observed data and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><annotation encoding="application/x-tex">\hat{y}_i</annotation></semantics></math>
is the predicted data. Therefore, the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>S</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">MSE</annotation></semantics></math>
(and the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">RMS</annotation></semantics></math>)
is simply the the average of the squared residuals.</p>
<p>Then, if we take the square root of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">RMS</annotation></semantics></math>
we get the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><mi>S</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">RMSE</annotation></semantics></math>
which is the root mean squared error.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><mi>S</mi><mi>E</mi><mo>=</mo><msqrt><mrow><mi>M</mi><mi>S</mi><mi>E</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">
RMSE = \sqrt{MSE} \tag{Equation-17}
</annotation></semantics></math></p>
<p>We generally use the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><mi>S</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">RMSE</annotation></semantics></math>
as the standard deviation of the regression. But, the denominator is not
always
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mi>n</mi></mfrac><annotation encoding="application/x-tex">\frac{1}{n}</annotation></semantics></math>).
It is typically
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mi>K</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{1}{n - K}</annotation></semantics></math>)
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
is the number of parameters that the model is fit with. Therefore, we
can write the standard deviation of the regression
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>s</mi><annotation encoding="application/x-tex">s</annotation></semantics></math>)
as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><msqrt><mrow><mfrac><mn>1</mn><mrow><mi>n</mi><mo>−</mo><mi>K</mi></mrow></mfrac><mo>⋅</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><msub><mover><mi>y</mi><mo accent="true">̂</mo></mover><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msqrt></mrow><annotation encoding="application/x-tex">
s = \sqrt{\frac{1}{n-K} \cdot \sum_{i=1}^{n} (y_{i} - \hat{y}_{i})} \tag{Equation-18}
</annotation></semantics></math></p>
<p>So, given that we are only dealing with models with two parameters,
this small difference can probably be ignored and we can use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>M</mi><mi>S</mi><mi>E</mi></mrow><annotation encoding="application/x-tex">RMSE</annotation></semantics></math>
as a measure of the standard deviation of the model.</p>
</div>
</div>
<div class="section level2">
<h2 id="preservation-effects">Preservation effects<a class="anchor" aria-label="anchor" href="#preservation-effects"></a>
</h2>
<p>The recommended approach to generating length-dry biomass equations
is to use fresh specimens or frozen specimens (Benke et al. 1999). This
is because preservation in commonly used preservatives like formalin and
ethanol can cause mass loss as lipids and other compounds may
dissolve.</p>
<p>Loss in dry mass due to preservation can be substantial. For example,
Mahrlein et al. (2016, <em>Hydrobiologia</em>) report dry weight loss of
more than 20% due to preservation in ethanol. Similarly, Wetzel et
al. (2005, <em>Helgoland Marine Researcg</em>) report dry weight loss of
more than 30% due to both formalin and ethanol preservation. This is in
contrast to the common doctrine that preservation-induced mass loss is
less prevalent when animals are preserved in formalin (Leuven et
al. 1985, <em>Hydrobiologia</em>). These numbers (20% or 30%) are
significant and, therefore, we should do our best to account for them to
the best of our ability.</p>
<p>Generating equations or gathering test data that used different
preservation methods can lead to a large additional source of error when
estimating dry biomass. However, there is another issue with
preservation methods. Usually, we want to estimate dry biomass for
communities or species that were collected and preserved. However,
individuals that are preserved in ethanol or formalin can also change
their lengths. Thus, when these preserved individuals are measured for
length, the measured lengths can be incorrect.</p>
<p>We need to look carefully at which preservation methods were used to
generate the equation and which preservation is used for the testing
data or for the dataset where the length data come from. We have added
this information and proposed correction factors for the equations in
the equation database. However, given that there are not enough
correction factors available in the literature, we have, as of yet, not
implemented these corrections into the standard output of
<code>InvAlloR</code>.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by James Hagan.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.2.</p>
</div>

    </footer>
</div>





  </body>
</html>
